import { IContext, IValidationResult, IStateTreeNode, ModelPrimitive } from "../../internal";
export interface IType<C, S, T> {
    name: string;
    create(snapshot?: C, environment?: any): T;
    is(thing: any): thing is C | S | T;
    validate(thing: any, context: IContext): IValidationResult;
    describe(): string;
    Type: T;
    SnapshotType: S;
    CreationType: C;
}
export interface IAnyType extends IType<any, any, any> {
}
export interface ISimpleType<T> extends IType<T, T, T> {
}
export declare type Primitives = ModelPrimitive | null | undefined;
export declare type TAndInterface<T, I> = (Exclude<T, Primitives> & I) | Extract<T, Primitives>;
export interface IComplexType<C, S, T> extends IType<C, S, T> {
    readonly "!!complexType": undefined;
    create(snapshot?: C, environment?: any): TAndInterface<T, {
        toJSON?(): S;
    } & IStateTreeNode<C, S>>;
}
export interface IAnyComplexType extends IComplexType<any, any, any> {
}
export declare type ExtractC<T extends IAnyType> = T extends IType<infer C, any, any> ? C : never;
export declare type ExtractS<T extends IAnyType> = T extends IType<any, infer S, any> ? S : never;
export declare type ExtractT<T extends IAnyType> = T extends IType<any, any, infer X> ? X : never;
export declare type ExtractIStateTreeNode<C, S, T> = T extends ModelPrimitive ? T : TAndInterface<T, IStateTreeNode<C, S>>;
export declare type Instance<T> = T extends IStateTreeNode ? T : T extends IType<any, any, infer TT> ? TT : T;
export declare type SnapshotIn<T> = T extends IStateTreeNode<infer STNC, any> ? STNC : T extends IType<infer TC, any, any> ? TC : T;
export declare type SnapshotOut<T> = T extends IStateTreeNode<any, infer STNS> ? STNS : T extends IType<any, infer TS, any> ? TS : T;
/**
 * A type which is equivalent to the union of SnapshotIn and Instance types of a given typeof TYPE or typeof VARIABLE.
 * For primitives it defaults to the primitive itself.
 *
 * For example:
 * - SnapshotOrInstance<typeof ModelA> = SnapshotIn<typeof ModelA> | Instance<typeof ModelA>
 * - SnapshotOrInstance<typeof self.a (where self.a is a ModelA)> = SnapshotIn<typeof ModelA> | Instance<typeof ModelA>
 *
 * Usually you might want to use this when your model has a setter action that sets a property.
 *
 * @example
 * const ModelA = types.model({
 *   n: types.number
 * })
 *
 * const ModelB = types.model({
 *   innerModel: ModelA
 * }).actions(self => ({
 *   // this will accept as property both the snapshot and the instance, whichever is preferred
 *   setInnerModel(m: SnapshotOrInstance<typeof self.innerModel>) {
 *     self.innerModel = cast(m)
 *   }
 * }))
 */
export declare type SnapshotOrInstance<T> = SnapshotIn<T> | Instance<T>;
/**
 * Returns if a given value represents a type.
 *
 * @export
 * @param {*} value
 * @returns {value is IAnyType}
 */
export declare function isType(value: any): value is IAnyType;
